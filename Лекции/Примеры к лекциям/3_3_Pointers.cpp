#include <iostream>
using namespace std;

int main() {
  int *a, b = 1; //а -- указатель, b -- обычная переменная
  a = &b;        //в а занесен адрес переменной b
  cout << (*a) << endl; //вывод значения по адресу указателя а, оно равно b
  cout << (b) << endl; //чтобы в этом убедиться, выводим b
  //обратите внимание, a и b относятся к одному и тому же участку памяти!
  b++; //для доказательства увеличим b на 1
  cout << (b) << endl;  //и выведем на экран b
  cout << (*a) << endl; //и значение а

  //вывод указателя а, это значение в шестадцатиричном формате
  cout << a << endl;
  a++; //увеличим адрес на единицу
  //и снова выведем на экран. Разница в адресах ровно 4 байта!
  cout << a << endl; 
  // вывод значения по новому адресу. Мы его никак не меняли,
  //поэтому содержимое ячейки неизвестно. В таких случаях говорят, что там
  //хранится мусор. Вообще говоря, такое произвольное изменение адреса может
  //повлечь за собой появление критической ошибки в программе и она аварийно
  //завершится. Поэтому рекомендуется его использовать только внутри выделенной
  //для работы памяти.
  cout << (*a) << endl;

  int *c; //еще один указатель, пока что он не связан с конкретным участком
          //памяти
  c = new int; //выделение памяти под этот указатель
  (*c) = 5;    //присвоение значения по адресу
  cout << (*c) << endl; //вывод содержимого ячейки
  cout << c << endl;    //вывод ее адреса
  delete c; //очистка памяти после того, как указатель не нужен
  return 0;
}
